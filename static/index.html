<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>pileUp</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    html, body, #stream { margin: 0; padding: 0; width: 100%; height: 100% }
    nav { width: 100%; background: black; color:white; height: 50px; }
    nav img { margin-left:10px; height: 50px; }
    #stream { position:absolute; left:0; top:50px; background: #0e3f4c; width:400px; height: calc(100% - 50px); }
    #notepad { background: #0a2834; padding:10px; margin: 5px;}
    #posts { background: #0a2834; margin:5px; padding:10px;}
    #posts p { min-height: 30px; background: aliceblue; padding:10px; }
    #posts p.dragging { background: white; opacity: 50% }
    #canvas { position: absolute; left:400px; width: calc(100% - 400px); top: 50px; background: cadetblue;
        height: calc(100% - 50px ); }
    g rect { filter: drop-shadow(3px 5px 2px rgb(0 0 0 / 0.4)) }
    .card rect { fill: aliceblue; }
    .node rect { fill: white; stroke: #999 }
    .pile rect { fill: bisque;  }
    .pile.home rect { fill: #96e9cf }
    .pile rect.droptarget { fill: #bb8749 } /* dummy rule for color skittle in editor */
    .pile .name { font-weight: bold }
    body { font-family: "Calibri" }
    #ghost { position:absolute; left: 0; top:0; width:100px; height: 60px; z-index: 1;
        background: white; border:solid #333 1px; opacity: 90%; display:none;
        box-shadow: #00000033 5px 5px 3px 3px; }
    #crumbs { display: inline-block; padding:0; margin:0; position:relative; top:-15px; }
    #crumbs li { display: inline; }
    #crumbs li:before { content: " â†’ "; font-family: "consolas"; color: white !important; }
    #crumbs li:first-child:before { content: " " }
    #crumbs li:hover, .pile a:hover { cursor: pointer }
    #ctx-menu { position:absolute; left:0; top:0; margin:0; background:#333; color: white; }
    .ctx { padding: 0; border: 0; filter: drop-shadow(3px 5px 2px rgb(0 0 0 / 0.4)) }
    .ctx ul { padding: 0; margin: 0; }
    .ctx li { display: block; padding:5px; margin:0; }
    .ctx li:hover { background: #444; cursor: default }
  </style>
</head>
<body>

<nav>
  <img src="/static/pileup-logo.svg"/>
  <ul id="crumbs">
  </ul>
</nav>

<div id="stream">
  <form id="notepad">
    <textarea name="text" rows="8" cols="48"></textarea>
    <br/>
    <button type="button" onclick="addScrap()">post</button>
  </form>
  <div id="posts">
  </div>
</div>

<div id="ghost">
</div>

<svg id="canvas">
</svg>

<dialog id="ctx-menu" class="ctx">
  <ul></ul>
</dialog>

<script>

  const HOME = '@inbox'
  // !! if we start at #foo and foo is not a child of @home, the
  //    crumbs will still say HOME -> foo. The alternative would
  //    be to calculate all of foo's ancestors. (TODO?)
  let model = {scraps:[], piles:[], pile:null, crumbs:[HOME]} // pile initialized in gotoPile at bottom

  // -- utils ------------------------------------------------

  $  = x => document.querySelector(x) // !! "Illegal invocation" w/o arrow
  $$ = x => document.querySelectorAll(x)

  function jFetch(url, method, body) { // json-flavored fetch()
    var req;
    if (method=='GET' || !method) { req = fetch(url) }
    else { req = fetch(url,
      {method, headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body)}) }
    return req.then(res=>res.json()) }

  function isOver(elem, e) { // did mouse event happen over this element?
    let r = elem.getBoundingClientRect()
    let ex = e.sourceEvent.clientX, ey = e.sourceEvent.clientY
    return (ex >= r.x && ex - r.x < r.width) && (ey >= r.y && ey - r.y < r.height) }

  // -- drawing the scene ------------------------------------

  pileData = ()=>(model.pile?._id == HOME) ? model.piles : [...model.piles, {_id:HOME, text:HOME}]
  getPiles = sel=> d3.select("#canvas").selectAll(sel||'g').data(pileData())

  function defaultScene() { // when no .scene is present
    let ofsx = 20, boxw = 300, gapw = 10, cols = 3,
        ofsy = 20, boxh = 180, gaph = 10
    return pileData().map((d,i)=> ({
      _id: d._id, c: 'pile',
      x: ofsx + i % cols * (boxw + gapw),
      y: ofsy + Math.floor(i/cols) * (boxh + gaph),
      w: boxw, h: d.text==HOME ? boxh/2 : boxh,
      text: d.text })) }

  function drawScene(scene) {
    return d3.select('#canvas').selectAll('g').data(scene)
      .join('g')
        .attr('class',d=>d.c||'node').attr('transform', d=>`translate(${d.x},${d.y})`)
        .html((d,i)=>`
          <rect width="${d.w}" height="${d.h}"></rect>
          <text class="name" x="10" y="20"><a>${d.text}</a></text>`)
      .each(function() { d3.select(this).select('text a').on('click', (e,d)=>gotoPile(d.text)) })
      .classed('home',d=>d._id==HOME) }

  function addScrapToScene(scrap, at) {
    console.log('addscrap', scrap, at)
    let scene = model.pile.scene
    let card = {_id: scrap._id, c:"card", ...at, w:200, h:30, text:scrap.text }
    scene.push(card) // !! draw twice. second time we'll know the correct width
    let newCard = drawScene(scene).filter(d=>d._id == scrap._id)
    card.w = 20 + Math.round(newCard.select('text').node().getBBox().width)
    drawScene(scene) }

  // -- the inbox --------------------------------------------

  function ghostToMouse(e,d) { // move "ghost" when dragging scraps from inbox
    return d3.select('#ghost')
      .style('left', `${e.sourceEvent.clientX - 10}px`)
      .style('top', `${e.sourceEvent.clientY -25}px`) }

  function mouseToCanvas(e) {
    let cr = $("#canvas").getBoundingClientRect()
    return { x: e.sourceEvent.clientX - Math.round(cr.x),
             y: e.sourceEvent.clientY - Math.round(cr.y)} }

  function drawScraps() {
    let scraps = d3.select('#posts').selectAll('p'),
        cached = {piles:[]}
    scraps.data(model.scraps, d=>d._id).join('p').html(d=>d.text).call(d3.drag()
      .on('start', function (e,d){  // d is the scrap
        cached.piles = getPiles()
        d3.select(this).classed('dragging', true)
        ghostToMouse(e,d).style('display','block') })
      .on('drag', (e,d)=>{ ghostToMouse(e,d)
        // now highlight the pile we'd drop to
        cached.piles.select('rect').each(function(d,i){
          d3.select(this).transition().duration(250).ease(d3.easeLinear)
            .style('fill', isOver(this, e) ? '#bb8749' : '') }) })
      .on('end', function (e, d, i){
        let el = d3.select(this).classed('dragging', false)
        d3.select('#ghost').style('display','none')
        cached.piles.select('rect').transition().duration(250).ease(d3.easeLinear).style('fill', '')
        let target = cached.piles.select('rect').filter(function(){return isOver(this, e)}),
            dropped = true, toPile=model.pile._id
        if (target.size()) { toPile = target.data()[0]._id }
        else if (isOver($("#canvas"), e)) {
          addScrapToScene(d, mouseToCanvas(e))
          let p = {...model.pile}; delete p.items // don't store redundant .items info
          jFetch(`/p/${toPile}`, 'PUT', p)}
        else dropped = false
        if (dropped) {
          jFetch(`/s/${d._id}`, 'PUT', {pile: toPile})
          el.remove(); model.scraps.splice(i, 1) } })) }

  function addScrap() {
    let scrap = $('#notepad').text, text = scrap.value
    jFetch(`/p/${model.pile._id}`, 'POST', {text}).then(res=>{
      scrap.value = ''
      model.scraps.unshift({_id: res.id, text})
      drawScraps() }) }

  function drawCrumbs() {
    d3.select('#crumbs').selectAll('li').data(model.crumbs).join('li').text(d=>d)
      .on('click', (e,d) => { if (d != model.pile._id) gotoPile(d) })}

  function gotoPile(which) {
    document.location.hash = (which==HOME) ? '' : `#${which}`
    if (which != model.pile?._id) {
      let ix = model.crumbs.indexOf(which)
      if (ix > -1) { model.crumbs = model.crumbs.slice(0, ix + 1) } // jump to crumb
      else { model.crumbs.push(which) }
      model.pile = {_id: which} // temp
      drawCrumbs() }
    model.scraps = []; model.piles = [];
    jFetch(`/p/${which}`).then(data=>{
      model.pile = data
      model.piles = data.items.filter(d=>d.type=='pile')

      if (!data.scene) data.scene = defaultScene()
      let inScene = {} // anything not in the scene is an inbox scrap
      data.scene.forEach(d=>{ inScene[d._id] = d })
      model.scraps = []
      data.items.forEach(d=>{ var ref
        if (ref = inScene[d._id]) ref.text = d.text
        else model.scraps.push(d) })

      model.piles.filter(d=>!inScene[d._id]).forEach(d=>{
        // !! what to do about it? (scrap? auto-add to scene?)
        console.warn('sub-pile not found in scene:', d) })

      drawScene(data.scene); drawScraps(); addMenus() }) }

  // -- menus -----------------------------------------------

  function ctxMenu(x,y,node) {
    let d = node.__data__,
        menu = d3.select('#ctx-menu')
          .style('left', `${x}px`).style('top', `${y}px`),
        options = [`tag: ${node.tagName}`]
    if (d) options.unshift(`type: ${d.type ? d.type : 'scrap'}`, `id: ${d._id}`)
    menu.selectAll('li').data(options).join('li').text(d=>d)
    menu.node().show() }

  function addMenus() {
    d3.selectAll('#canvas, #posts p, #canvas g').on('click', function(e) {
        d3.select('#ctx-menu').node().close()
        e.preventDefault(); })
      .on('contextmenu', function(e) {
        // !! phase 2 is the 'target' phase for dom events, when it hits the actual element
        //    (without this check, #canvas would override rect events in phase 3 ('bubbling'))
        if (e.eventPhase > 2 && this.tagName == 'svg') return;
        ctxMenu(e.clientX, e.clientY, this)
        e.preventDefault() })
      .on('mousedown', function(e) {
        if (e.button == 1) {
          console.log(`middle-click: x: ${e.clientX}, y: ${e.clientY}`) }}) }

  // -- begin ------------------------------------------------

  gotoPile(document.location.hash.substr(1) || HOME)

</script>
</body>
</html>
