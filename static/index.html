<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>pileUp</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    html, body, #stream { margin: 0; padding: 0; width: 100%; height: 100% }
    nav { width: 100%; background: black; color:white; height: 50px; }
    nav img { margin-left:10px; height: 50px; }
    #stream { position:absolute; left:0; top:50px; background: #0e3f4c; width:400px; height: calc(100% - 50px); }
    #notepad { background: #0a2834; padding:10px; margin: 5px;}
    #posts { background: #0a2834; margin:5px; padding:10px;}
    #posts p { min-height: 30px; background: aliceblue; padding:10px; }
    #posts p.dragging { background: white; opacity: 50% }
    #canvas { position: absolute; left:400px; width: calc(100% - 400px); top: 50px; background: cadetblue;
        height: calc(100% - 50px ); }
    #scene rect { filter: drop-shadow(3px 5px 2px rgb(0 0 0 / 0.4)) }
    .card rect { fill: aliceblue; }
    .card { cursor: grab }
    .card.drag { cursor: grabbing }
    .card.selected rect { stroke:black; stroke-width: 2; }
    .node rect { fill: white; stroke: #999 }
    .pile rect { fill: bisque;  }
    .pile.home rect { fill: #96e9cf }
    .pile rect.droptarget { fill: #bb8749 } /* dummy rule for color skittle in editor */
    .pile .name { font-weight: bold }
    body { font-family: "Calibri" }
    #ghost { position:absolute; left: 0; top:0; width:100px; height: 60px; z-index: 1;
        background: white; border:solid #333 1px; opacity: 90%; display:none;
        box-shadow: #00000033 5px 5px 3px 3px; }
    #crumbs { display: inline-block; padding:0; margin:0; position:relative; top:-15px; }
    #crumbs li { display: inline; }
    #crumbs li:before { content: " â†’ "; font-family: "consolas"; color: white !important; }
    #crumbs li:first-child:before { content: " " }
    #crumbs li:hover, .pile a:hover { cursor: pointer }
    #ctx-menu { position:absolute; left:0; top:0; margin:0; background:#333; color: white; }
    .ctx { padding: 0; border: 0; filter: drop-shadow(3px 5px 2px rgb(0 0 0 / 0.4)) }
    .ctx ul { padding: 0; margin: 0; }
    .ctx li { display: block; padding:5px; margin:0; }
    .ctx li:hover { background: #444; cursor: default }
    #lasso .handle { visibility: hidden }
  </style>
</head>
<body>

<nav>
  <img src="/static/pileup-logo.svg"/>
  <ul id="crumbs">
  </ul>
</nav>

<div id="stream">
  <form id="notepad">
    <textarea name="text" rows="8" cols="48"></textarea>
    <br/>
    <button type="button" onclick="addScrap()">post</button>
  </form>
  <div id="posts">
  </div>
</div>

<div id="ghost">
</div>

<svg id="canvas">
  <g id="scene"></g>
  <g id="lasso" transform="translate(500,300)" style="visibility: hidden">
    <rect class="rope" width="300" height="180" fill="transparent" stroke="#333" stroke-dasharray="4 1"></rect>
    <rect class="rope" width="300" height="180" fill="transparent" stroke="#fff" stroke-dasharray="1 4"></rect>
  </g>
  <g id="selectangle" transform="translate(0,0)" style="visibility: hidden">
    <rect class="rope" width="300" height="180" fill="transparent" stroke="#ccc" stroke-width="2"></rect>
    <rect class="handle n w" x="-4" y="-4" width="9" height="9" fill="#ccc" stroke="#333"></rect>
    <rect class="handle n e" x="295" y="-4" width="9" height="9" fill="#ccc" stroke="#333"></rect>
    <rect class="handle s w" x="-4" y="175" width="9" height="9" fill="#ccc" stroke="#333"></rect>
    <rect class="handle s e" x="295" y="175" width="9" height="9" fill="#ccc" stroke="#333"></rect>
  </g>
</svg>

<dialog id="ctx-menu" class="ctx">
  <ul></ul>
</dialog>

<script>

  const HOME = '@inbox'
  // !! if we start at #foo and foo is not a child of @home, the
  //    crumbs will still say HOME -> foo. The alternative would
  //    be to calculate all of foo's ancestors. (TODO?)
  let model = {scraps:[], piles:[], pile:null, crumbs:[HOME]} // pile initialized in gotoPile at bottom

  // -- utils ------------------------------------------------

  $  = x => document.querySelector(x) // !! "Illegal invocation" w/o arrow
  $$ = x => document.querySelectorAll(x)

  function jFetch(url, method, body) { // json-flavored fetch()
    var req;
    if (method=='GET' || !method) { req = fetch(url) }
    else { req = fetch(url,
      {method, headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(body)}) }
    return req.then(res=>res.json()) }

  function isOver(elem, e) { // did mouse event happen over this element?
    let r = elem.getBoundingClientRect()
    let ex = e.sourceEvent.clientX, ey = e.sourceEvent.clientY
    return (ex >= r.x && ex - r.x < r.width) && (ey >= r.y && ey - r.y < r.height) }

  function overlaps(a, b) { // two DOMRect values from .getBoundingClientRect
    return (a.left < b.right) && (a.right > b.left)
        && (a.top < b.bottom) && (a.bottom > b.top) }

  function bounds(rects) {
    let res = {x:Infinity, y:Infinity, x1:-Infinity, y1:-Infinity}
    rects.forEach(r=>{
      res.x = Math.min(res.x, r.x); res.x1=Math.max(res.x1, r.right)
      res.y = Math.min(res.y, r.y); res.y1=Math.max(res.y1, r.bottom) })
    return new DOMRect(res.x, res.y, res.x1-res.x, res.y1-res.y) }

  // -- drawing the scene ------------------------------------

  pileData = ()=>(model.pile?._id == HOME) ? model.piles : [...model.piles, {_id:HOME, text:HOME}]
  getPiles = sel=> d3.select("#scene").selectAll(sel||'g').data(pileData(), d=>d._id)

  function defaultScene() { // when no .scene is present
    let ofsx = 20, boxw = 300, gapw = 10, cols = 3,
        ofsy = 20, boxh = 180, gaph = 10
    return pileData().map((d,i)=> ({
      _id: d._id, c: 'pile',
      x: ofsx + i % cols * (boxw + gapw),
      y: ofsy + Math.floor(i/cols) * (boxh + gaph),
      w: boxw, h: d.text==HOME ? boxh/2 : boxh,
      text: d.text })) }

  function drawScene(scene) {
    return d3.select('#scene').selectAll('g').data(scene)
      .join('g')
        .attr('class',d=>d.c||'node').attr('transform', d=>`translate(${d.x},${d.y})`)
        .html((d,i)=>`
          <rect width="${d.w}" height="${d.h}"></rect>
          <text class="name" x="10" y="20"><a>${d.o.text}</a></text>`)
      .each(function() { d3.select(this).select('.pile text a').on('click', (e,d)=>gotoPile(d.o.text)) })
      .classed('home',d=>d._id==HOME)
      .filter(d=>d.c!='pile').call(makeDraggable)}

  function makeDraggable(d3s) {
    let start = {x:0, y:0}
    let fn = d3.drag()
      .on('start', function(e,d){
        let p = mouseToCanvas(e)
        start = { x:p.x-d.x, y:p.y-d.y}})
      .on('drag', function(e,d){
        let p = mouseToCanvas(e)
        d.x = p.x-start.x, d.y = p.y-start.y // both this.__data__ and model.pile.scene
        d3.select(this).attr('transform', `translate(${d.x},${d.y})`) })
      .on('end', storeScene)
    fn(d3s) }

  function addScrapToScene(scrap, at) {
    let scene = model.pile.scene
    let card = {_id: scrap._id, c:"card", ...at, w:200, h:30, text:scrap.text }
    scene.push(card) // !! draw twice. second time we'll know the correct width
    let newCard = drawScene(scene).filter(d=>d._id == scrap._id)
    card.w = 20 + Math.round(newCard.select('text').node().getBBox().width)
    drawScene(scene) }

  function storeScene() {
    let p = {...model.pile}; delete p.items // don't store redundant .items info
    // only store the things that can't be derived from the items themselves:
    p.scene = p.scene.map(o => ({_id:o._id, c:o.c, x:o.x, y:o.y, w:o.w, h:o.h }) )
    return jFetch(`/p/${model.pile._id}`, 'PUT', p)
      .then(r=>{ model.pile._rev = r.rev; }) }

  function updateNode(id, kw) { // -> promise
    let ref = model.pile.items.find(x=>x._id == id)
    if (ref) {
      Object.assign(ref, kw)
      return jFetch(`/s/${id}`, 'PUT', ref).then(res=>{
        Object.assign(ref, {_rev: res.rev}) })}
    else (console.warn(`tried to update non-existant node: ${id}`)) }

  // -- the inbox --------------------------------------------

  function ghostToMouse(e,d) { // move "ghost" when dragging scraps from inbox
    return d3.select('#ghost')
      .style('left', `${e.sourceEvent.clientX - 10}px`)
      .style('top', `${e.sourceEvent.clientY -25}px`) }

  function clientToCanvas(p) {
    let cr = $("#canvas").getBoundingClientRect()
    return { x: Math.round(p.x - cr.x), y: Math.round(p.y - cr.y) }}

  function mouseToCanvas(e) {
    return clientToCanvas({ x: e.sourceEvent.clientX, y: e.sourceEvent.clientY }) }

  function drawScraps() {
    let scraps = d3.select('#posts').selectAll('p'),
        cached = {piles:[]}
    scraps.data(model.scraps, d=>d._id).join('p').html(d=>d.text).call(d3.drag()
      .on('start', function (e,d){  // d is the scrap
        cached.piles = getPiles()
        d3.select(this).classed('dragging', true)
        ghostToMouse(e,d).style('display','block') })
      .on('drag', (e,d)=>{ ghostToMouse(e,d)
        // now highlight the pile we'd drop to
        cached.piles.select('rect').each(function(d,i){
          d3.select(this).transition().duration(250).ease(d3.easeLinear)
            .style('fill', isOver(this, e) ? '#bb8749' : '') }) })
      .on('end', function (e, d, i){
        let el = d3.select(this).classed('dragging', false)
        d3.select('#ghost').style('display','none')
        cached.piles.select('rect').transition().duration(250).ease(d3.easeLinear).style('fill', '')
        let target = cached.piles.select('rect').filter(function(){return isOver(this, e)}),
            dropped = true, toPile=model.pile._id
        if (target.size()) { toPile = target.data()[0]._id }
        else if (isOver($("#canvas"), e)) {
          addScrapToScene(d, mouseToCanvas(e))
          storeScene()}
        else dropped = false
        if (dropped) {
          jFetch(`/s/${d._id}`, 'PUT', {pile: toPile})
          el.remove(); model.scraps.splice(i, 1) } })) }

  function addScrap() {
    let scrap = $('#notepad').text, text = scrap.value
    jFetch(`/p/${model.pile._id}`, 'POST', {text}).then(res=>{
      scrap.value = ''
      model.scraps.unshift({_id: res.id, text})
      drawScraps() }) }

  function drawCrumbs() {
    d3.select('#crumbs').selectAll('li').data(model.crumbs).join('li').text(d=>d)
      .on('click', (e,d) => { if (d != model.pile._id) gotoPile(d) })}

  function gotoPile(which) {
    document.location.hash = (which==HOME) ? '' : `#${which}`
    if (which != model.pile?._id) {
      let ix = model.crumbs.indexOf(which)
      if (ix > -1) { model.crumbs = model.crumbs.slice(0, ix + 1) } // jump to crumb
      else { model.crumbs.push(which) }
      model.pile = {_id: which} // temp
      drawCrumbs() }
    model.scraps = []; model.piles = [];
    jFetch(`/p/${which}`).then(data=>{
      model.pile = data
      model.piles = data.items.filter(d=>d.type=='pile')

      if (!data.scene) data.scene = defaultScene()
      let inScene = {} // anything not in the scene is an inbox scrap
      data.scene.forEach(d=>{ inScene[d._id] = d })
      model.scraps = []
      if (model.pile._id !== HOME) { inScene[HOME].o = { text: HOME } }
      data.items.forEach(d=>{ let ref = inScene[d._id]
        if (ref) { ref.o = d } else model.scraps.push(d) })

      model.piles.filter(d=>!inScene[d._id]).forEach(d=>{
        // !! what to do about it? (scrap? auto-add to scene?)
        console.warn('sub-pile not found in scene:', d) })

      drawScene(data.scene); drawScraps(); addMenus() }) }

  // -- menus -----------------------------------------------

  let ok = ()=>{}
  function ctxMenu(x,y,node) {
    let d = node.__data__,
        menu = d3.select('#ctx-menu')
          .style('left', `${x}px`).style('top', `${y}px`),
        options = [[`tag: ${node.tagName}`,ok]]
    let t = d?.c || 'scrap'; switch (t) {
      case 'card':
        options.push(['convert to pile', d=>{
          updateNode(d._id, {type:'pile'})
            .then (()=>{
              d.c = 'pile'
              drawScene(model.pile.scene)
              storeScene() }) }])
        break
      default: }

    if (d) options.unshift([`${t} ${d._id}`, ok])
    menu.selectAll('li').data(options).join('li').text(dd=>dd[0])
      .on('click', (e,dd)=>{ dd[1](d) })
    menu.node().show() }

  function addMenus() {
    d3.select('#ctx-menu').on('contextmenu', e=>e.preventDefault())
    d3.selectAll('#canvas, #posts p, #scene g, #selectangle').on('click', function(e) {
        d3.select('#ctx-menu').node().close()
        e.preventDefault(); })
      .on('contextmenu', function(e) {
        // !! phase 2 is the 'target' phase for dom events, when it hits the actual element
        //    (without this check, #canvas would override rect events in phase 3 ('bubbling'))
        if (e.eventPhase > 2 && this.tagName == 'svg') return;
        ctxMenu(e.clientX, e.clientY, this)
        e.preventDefault() })
      .on('mousedown', function(e) {
        if (e.button == 1) {
          console.log(`middle-click: x: ${e.clientX}, y: ${e.clientY}`)
          e.preventDefault() }}) }

  // -- dragging on canvas makes a (rectangular) lasso -------

  function moveBox(selector, a,b) { // draw rectangle with corners a and b
    let x = Math.min(a.x, b.x), w = Math.max(a.x, b.x) - x,
        y = Math.min(a.y, b.y), h = Math.max(a.y, b.y) - y
    let s = d3.select(selector)
    s.attr('transform', `translate(${x}, ${y})`)
    s.selectAll('.e').attr('x', w-5)
    s.selectAll('.s').attr('y', h-5)
    s.selectAll('.rope').attr('width', w).attr('height', h)
    return s }

  let p0
  d3.select('#canvas').call(d3.drag()
    .on('start', function(e){
      if (e.sourceEvent.eventPhase != 2) return;
      p0 = mouseToCanvas(e)
      moveBox('#lasso', p0, p0).style('visibility','visible') })
    .on('drag', e => { if (p0) moveBox('#lasso', p0, mouseToCanvas(e)) })
    .on('end', ()=> {
      p0=undefined
      let lr = d3.select('#lasso').style('visibility','hidden').node().getBoundingClientRect()
      d3.selectAll('#scene .card').classed('selected', function() {
        return overlaps(lr, this.getBoundingClientRect()) })
      // draw the selectangle around the selected objects:
      let sel = d3.selectAll('.selected')
      if (sel.size()) {
        let r = bounds(sel.nodes().map(x=>x.getBoundingClientRect()))
        moveBox('#selectangle', clientToCanvas({x:r.left, y:r.top}), clientToCanvas({x:r.right, y:r.bottom}))
          .style('visibility','visible') }
      else d3.select('#selectangle').style('visibility', 'hidden') }))

  // -- dragging selectangle drags all selected --------------
  // let p0 // already defined above for canvas
  let s0 // initial position of the selectangle
  function dragSelection(el, e, bake){
    let p = mouseToCanvas(e)
    let q = {x:p.x-p0.x, y:p.y-p0.y}
    let r = {x:q.x-s0.x, y:q.y-s0.y} // relative distance since start of drag
    d3.select(el).attr('transform', `translate(${q.x},${q.y})`)
    d3.selectAll('.selected').attr('transform', d=>{
      let x = d.x+r.x, y = d.y+r.y
      if (bake) { d.x=x; d.y=y }
      return `translate(${x},${y})` })
    if (bake) storeScene() }

  d3.select('#selectangle').call(d3.drag()
    .on('start', function(e){
        let p = mouseToCanvas(e)
        s0 = clientToCanvas(d3.select('#selectangle').node().getBoundingClientRect())
        p0 = { x:p.x-s0.x, y:p.y-s0.y}})
      .on('drag', function(e) { dragSelection(this, e, 0) })
      .on('end', function(e) { dragSelection(this, e, 1) }))

  // -- begin ------------------------------------------------

  gotoPile(document.location.hash.substr(1) || HOME)

</script>
</body>
</html>
